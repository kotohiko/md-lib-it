> 本文全局中英文对照表
> OS：operating system，操作系统
> VM：virtual machine，虚拟机



# 1   概述



## 1.1   全面认识 Docker



<img src="./images/docker-logo-blue.png" style="zoom:4%;" />





[Docker](https://www.docker.com/) 是一个开源的「应用容器引擎（Container Engine）」，也是一个用于开发，交付和运行应用程序的「开放平台」。基于 Go 语言开发，遵从 Apache 2.0 协议。

Docker 可以让开发者将他们的「应用以及依赖」打包到一个轻量级、可移植的容器中，然后**发布到任何流行的 Linux 机器上，也可以实现「虚拟化」**。

容器使用了「沙箱（sandbox）」机制，相互之间不会有任何接口（类似 iPhone 的 App），更重要的是容器性能开销极低。

Docker 从 17.03 版本之后分为 CE（Community Edition，社区版） 和 EE（Enterprise Edition，企业版）。

### 1.1.1   GitHub 上找不到 Docker？

如果去 GitHub 搜索 Docker，会发现与简介里说的并不一致。这里似乎并没有所谓的「用 Go 开发的 Docker 项目」。

<img src="./images/github搜索docker.png"  />

那么是怎么回事呢？接下来将从几个方面来说明情况。

#### a. 项目名称与组织

Docker 的源代码确实有托管在 GitHub 上，但它并不直接叫「Go 语言开发的 Docker 项目」之类的名称。Docker 的源代码实际上托管在  Docker 官方的 GitHub 组织下，项目名称是 [Moby](https://github.com/moby/moby)。

Moby 是 Docker 的核心开源项目。Docker, Inc. 将核心部分重命名为 Moby，以便区分开源项目和 Docker 的商业产品。因此，如果你想查看 Docker 的 Go 语言代码，你可以访问 Moby 项目。

#### b. 项目历史

Docker 最初是作为一个开源项目发布的，后来随着生态系统的发展，它的组件和功能逐渐拆分成多个独立的子项目。虽然 Docker 的核心是用 Go 编写的，但它的代码库已经细分成多个相关项目，比如 [containerd](https://github.com/containerd/containerd)、[libnetwork](https://github.com/moby/libnetwork) 等。因此，找到所有与 Docker 相关的 Go 代码可能需要查看多个仓库。

#### c. 关键仓库

以下是几个与 Docker 核心相关的重要仓库，都是用 Go 语言编写的：

- Moby：Docker 引擎的「核心」部分，提供容器化的基本功能。

    GitHub 地址：https://github.com/moby/moby

- containerd：Docker 使用的容器运行时，负责容器的生命周期管理。

    GitHub 地址：https://github.com/containerd/containerd

- runc：Docker 使用的容器执行器，负责实际启动容器。

    GitHub 地址：https://github.com/opencontainers/runc

### 1.1.2   如何理解「虚拟」的概念

本文开篇有一句话：“发布到任何流行的 Linux 机器上，也可以实现「虚拟化」”。这里的「虚拟化」是什么意思呢？

在 VM 中，「虚拟」的概念并不意味着你使用的 OS（如 Linux）是模拟的或不真实的。实际上，VM 内运行的 OS 是「真实的」，只不过它是**在虚拟化环境中运行，而不是直接运行在物理硬件上**。

1. 「虚拟」的含义

    「虚拟」指的是**硬件的虚拟化**，即虚拟化技术使用**软件模拟了一套硬件资源（如 CPU、内存、存储等）**，使得不同 OS 可以在同一物理机上以隔离的方式运行，而不会相互干扰。VM 实际上是通过虚拟化层（如 VMware、VirtualBox 等）来创建一组虚拟的硬件设备，让 OS 认为它运行在自己的独立计算机上。

    「虚拟」在这里的含义可以理解为：**每个 OS “感觉” 自己拥有独立的硬件**。

2. 实际 OS vs. 虚拟环境

    -   倘若在 Windows 上使用 VMware 创建了一个 Linux VM。这个 Linux OS 是真正的 Linux，它有完整的功能，并且与直接安装在物理机上的 Linux 几乎没有区别。
    -   虚拟化的部分指的是 **VM 所使用的硬件资源是模拟的**，如虚拟的 CPU、内存、硬盘等。这些资源是通过 VMware 等虚拟化平台模拟的，但 Linux OS 并不知道它是在虚拟环境中运行，它会 “以为” 自己是在一台真实的计算机上工作。

3. VM vs. 模拟器

    还有一项常见的技术是模拟器，但 VM 和模拟器是不同的概念。

    -   VM：运行的是 OS 的真实版本，它只是通过虚拟化技术与其他 VM 或宿主 OS 共享硬件资源。
    -   模拟器：通常是通过软件来模拟不同平台的操作环境，常用于在不同的硬件架构上运行另一个平台的应用程序（比如在 Windows 上模拟 Android 环境）。模拟器并不是真实 OS，而是模仿某种系统的行为。

4. VM 的工作原理

    虚拟化技术使用一个称为 Hypervisor（VM 监控器）的软件层来管理多个 VM 的运行。Hypervisor 可以是宿主型（如 VMware Workstation，运行在 OS 之上）或裸机型（如 VMware ESXi，直接运行在物理硬件上）。Hypervisor 会分配物理资源（如 CPU、内存、硬盘空间等）给每个 VM，VM 通过这一层软件与物理硬件进行交互。

5. 总结

    在 VM 中，「虚拟」的意思是**硬件资源被虚拟化，而不是 OS 被模拟**。OS 是完整真实的，只是它运行在虚拟化的硬件环境中。虽然你在物理机上运行 Windows，但虚拟化技术**让 Linux OS 认为它拥有自己的独立硬件，并可以正常运行，就像它在真实计算机上一样。**

了解了「虚拟」的概念后，我们再来看 Docker 的「虚拟化」。「虚拟化」的理解需要结合 Docker 的工作机制。虽然 Docker 容器并不是真正的 VM，但它提供了一种类似虚拟化的功能，即**让应用程序在隔离的环境中运行，而不直接依赖底层宿主系统的具体配置**。具体来说：

- 【传统虚拟化】传统虚拟化技术（如 VMware、VirtualBox 等）会在物理服务器上创建多个 VM，**每个 VM 运行一个完整的 OS 和应用程序**。这种方式通过 Hypervisor（VM 监控器）来管理 VM，每个 VM 都有自己的 OS 内核，资源隔离度高，但占用的资源也较多，启动速度慢。

- 【Docker 中的虚拟化】Docker 并不使用传统的虚拟化方式，而是通过 OS 的**内核级别技术**（如 Linux 的 cgroups 和 namespaces）来实现「轻量级的虚拟化」。Docker 容器共享宿主机的 OS 内核，避免了运行多个完整 OS 的开销。因此，它不像 VM 那样占用大量资源，启动速度非常快。

    Docker 的「虚拟化」在这里的意思是：应用程序与宿主环境的隔离。每个容器有自己独立的文件系统、网络、进程空间等，虽然它与宿主系统共用同一个内核，但对于容器内部的应用来说，它感觉像是在一个独立的系统中运行。这种轻量级的虚拟化方式提供了类似 VM 的隔离效果，但更高效。

- 【虚拟化的特点在 Docker 中的体现】

    - 隔离性：每个容器都有自己的运行环境（文件系统、进程空间、网络接口等），确保应用之间互不干扰，类似 VM 中的 OS 隔离。
    - 轻量级：与 VM 不同，Docker 容器不需要运行自己的 OS，而是共享宿主机的 Linux 内核，这使得容器启动更快、占用资源更少。
    - 可移植性：容器包含应用程序和它所需的依赖，因此可以在不同的环境（如开发、测试、生产）中一致地运行，类似于 VM 的跨平台部署能力。

- Docker 与 VM 的对比：

    - VM：需要完整的 OS，启动慢，占用资源多，隔离性强。
    - Docker 容器：共享宿主机 OS 内核，启动快，占用资源少，隔离性也不错（虽然没有 VM 强，但对于大多数应用场景已经足够）。

总而言之，「虚拟化」指的是 Docker 通过容器技术实现的隔离和资源管理。虽然 Docker 与传统 VM 的虚拟化方式不同，但它同样提供了一种隔离的、轻量级的运行环境，让应用程序能够像在 VM 中一样独立运行，因此可以视为一种「虚拟化」技术的体现。



## 1.2   应用场景

- Web 应用的自动化打包和发布。
- 自动化测试和持续集成、发布。
- 在服务型环境中部署和调整数据库或其他的后台应用。
- 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。



## 1.3   优点

Docker 能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，可以大大减少编写代码和在生产环境中运行代码之间的延迟。

### 1.3.1   快速，一致地交付应用程序

Docker 允许开发人员在标准化环境中使用本地容器来运行应用程序或服务，从而简化了开发的生命周期。

容器非常适合**持续集成和持续交付（CI / CD）**工作流程，请考虑以下示例方案：

- 开发人员在本地编写代码，并通过 Docker 容器与同事共享他们的工作。
- 开发人员使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。
- 当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。
- 测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。


> Q：CI／CD 是什么意思？
>
> A：CI／CD 是**持续集成（Continuous Integration）**和**持续交付／持续部署（Continuous Delivery／Continuous Deployment）**的缩写，是现代软件开发和交付流程中的关键实践。
>
> - 持续集成（CI）：持续集成指的是开发者频繁地将代码集成到主代码库中，通常每天多次。每次代码提交都会触发自动化构建和测试流程，以确保新代码与现有代码兼容并且没有破坏软件的功能。
>     - 核心思想
>         - 频繁的代码集成可以更早地发现问题，避免 “大规模集成” 时的冲突和错误。
>         - 自动化的测试和构建流程确保每次集成都经过验证，使开发流程更加高效和可靠。
>     - 关键步骤
>         - 开发者提交代码到版本控制系统（如 Git）。
>         - 自动化构建工具编译代码。
>         - 自动化测试工具对代码进行单元测试、集成测试等。
>         - 如果构建或测试失败，系统会通知开发者。 
>
> - 持续交付（CD）：持续交付是在持续集成的基础上，确保代码可以随时发布到生产环境。每次通过自动化测试的代码都能够安全地部署到生产环境，只需要人工确认和执行发布操作。
>     - 核心思想
>         - 通过自动化测试、打包和部署管道，确保软件始终处于可发布的状态。
>         - 开发团队可以频繁地发布小版本，而不是等待大版本积累大量改动后再发布。
>     - 关键步骤
>         - 自动化部署管道将经过测试的代码部署到预生产或生产环境。
>         - 需要人工干预来决定何时发布。
>
> - 持续部署（CD）：持续部署是持续交付的进一步演进，即每次代码变更通过测试后，自动部署到生产环境，无需任何人工干预。它要求所有测试、部署环节高度自动化和可靠。
>     - 核心思想
>         - 每次代码变更（只要通过测试）都立即发布到生产环境，最大化自动化。
>         - 整个过程从代码提交到最终上线完全自动化。
>     - 关键步骤
>         - 自动化测试和部署完成后，代码立即上线，无需人工审批。
>
> - 总结
>     - CI（持续集成）：频繁集成代码，自动化测试和构建，确保代码质量。
>     - CD（持续交付）：代码随时可以发布，部署过程自动化，但需要人工确认发布。
>     - CD（持续部署）：代码自动发布到生产环境，完全自动化，无需人工干预。
>
> CI／CD 的目标是加快软件开发到发布的周期，减少人为错误，并保证高质量的软件交付。

### 1.3.2   响应式部署和扩展

Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或 VM 上，云服务上或混合环境中运行。

Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。

### 1.3.3   在同一硬件上运行更多工作负载

Docker 轻巧快速。它为基于 VM 管理程序的 VM 提供了可行、经济、高效的替代方案，因此可以利用更多的计算能力来实现业务目标。

Docker 非常适合于高密度环境以及中小型部署，可以用更少的资源做更多的事情。



# 2   Docker 的核心架构

Docker 包括三个基本概念：

- **镜像（Image）**：Docker 的镜像，就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。
- **容器（Container）**：镜像和容器的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。Docker 容器通过 Docker 镜像来创建。
- **仓库（Repository）**：仓库可看成一个代码控制中心，用来保存镜像。

Docker 使用客户端-服务器（C / S）架构模式，使用远程 API 来管理和创建 Docker 容器。



## 2.1   镜像

在 Docker 中，**镜像（Image）**是一个轻量级、独立、可执行的打包环境，包含了运行应用程序所需的所有内容，例如代码、运行时、库、环境变量和配置文件等。

**可以将镜像理解为应用程序的「快照」或「蓝图」**，它定义了应用程序的文件系统和运行时环境。镜像本身是**静态的、不可变**的，但它可以用于创建一个可运行的实例——也就是容器。具体来说，Docker 镜像的特点和工作原理包括：

1. 分层结构

    Docker 镜像是由**多个「只读」的层组成的**，每一层代表了对镜像的修改（比如安装软件包、添加配置文件等）。这种分层结构提高了存储效率，多个镜像可以共享相同的基础层（如 OS 层），减少重复数据。

2. 可复用性

    镜像是可复用的。开发者可以基于一个基础镜像（如 Ubuntu 或 Alpine）构建自己的应用镜像。每次你修改镜像，只需增加一层，而无需重新构建整个镜像。

3. 可移植性

    由于镜像包含了**运行应用程序的所有依赖项**，它可以在不同的主机和环境（如开发、测试、生产）中一致地运行。你可以把镜像打包好，**在不同的系统上部署而不会出现依赖问题**。

4. 可版本化

    每个镜像都有一个唯一的标识（通常为标签或 ID），开发者可以为同一应用程序的不同版本打不同的标签（tag，如 v1.0、latest）。这使得应用程序的**不同版本可以并存，方便切换或回滚**。

5. 镜像与容器的关系

    **镜像是容器的「模板」**。当你使用 Docker 镜像运行一个容器时，Docker 会从镜像生成一个可写层，允许对镜像做进一步的操作和修改。但这些修改只存在于容器中，不会影响原镜像。

举个简单的例子，假设你有一个 Node.js 应用，开发时你可以从官方的 Node 镜像开始构建，然后把你的代码和依赖添加到新的镜像层里。这个新的镜像包含了 Node.js 环境和你的应用代码，任何人都可以基于这个镜像快速启动你的应用。

总结来说，Docker 镜像是应用程序和运行环境的打包文件，具有分层、可复用、可移植的特性，是容器化应用的核心构件。



## 2.2   容器

Docker 中的容器可以理解为**基于镜像运行的独立实例**。它是一种**轻量级的虚拟化技术**，为应用程序提供了一个**隔离的运行环境**。与传统的 VM 相比，容器共享宿主机的 OS 内核，但对每个容器内部的应用来说，**它看起来像是运行在一个独立的系统中**。

以下是容器的一些核心概念，帮助理解其工作方式：

1. 基于镜像

    **容器是由镜像启动的**。镜像包含应用程序及其运行所需的所有依赖，而容器是镜像的一个运行时实例。在启动容器时，Docker 从镜像中加载必要的文件并启动应用。

2. 轻量级

    **容器不像 VM 那样需要运行一个完整的 OS**。它们依赖宿主机的「OS 内核」，避免了虚拟化 OS 带来的开销。因此，容器启动速度非常快，占用资源极少。

3. 隔离性

    每个容器都有自己**「独立」的文件系统、网络接口和进程空间**。这种隔离确保了一个容器内的应用程序无法干扰其他容器或宿主机。例如，容器内部运行的应用只能访问容器分配的资源，无法访问其他容器的文件系统或进程。

4. 可移植性

    由于容器的环境是完全隔离的，并且包含了应用运行的所有依赖，容器可以在任何支持 Docker 的主机上运行，不需要重新配置环境。这使得应用程序从开发环境迁移到测试、生产环境时更加简单可靠。

5. 可修改性

    当容器运行时，它会在镜像的基础上添加一个可写层，使得容器可以保存应用的动态数据（如日志、临时文件）。这个可写层只在容器存在时有效，当容器被删除时，这一层会被销毁。原始的镜像仍然保持不变。

6. 生命周期管理

    容器的生命周期非常灵活。你可以启动、停止、重启、删除容器，这与操作普通的应用程序类似。容器的可写层也可以通过持久化卷或绑定挂载来保存重要数据，即使容器被删除，数据仍然可以保留。

【容器和镜像的关系】

镜像是容器的模板，容器是镜像的运行时实例。镜像就像是一个“配方”，定义了应用程序的环境和依赖，而容器是按照这个配方启动的实际应用进程。你可以基于同一个镜像启动多个容器，这些容器之间彼此独立、互不干扰。

> Q：给我一些具有说服力的理由，证明 Docker 的容器比 VM 更高效？
> A：相比 VM，容器更高效的原因有以下几点：
>
> |            | Docker 容器                                                  | VM                                                           |
> | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 启动速度   | 容器的启动只需要启动应用程序及其依赖项，因为容器共享宿主机的 OS 内核，所以几乎是即时启动，通常只需要几秒甚至毫秒。 | VM 需要启动整个 OS，加载内核、驱动等，启动时间可能长达几分钟。 |
> | 资源占用   | 容器占用的 CPU、内存等资源相对少。它们依赖宿主 OS 的内核来运行，避免了重复的资源开销。 | VM 每个实例都包含一个完整的 OS，导致更多的资源消耗（如内存、CPU 等），因为每个 VM 都需要独立管理 OS 的资源。 |
> | 密度       | 在同一台物理主机上，可以运行更多的容器。因为容器轻量级、占用资源少，支持高密度部署（即在同一硬件上运行更多的应用实例）。 | 由于每个 VM 都需要一个完整的 OS，故相同硬件上 VM 的数量有限，容纳的应用实例较少。 |
> | 环境一致性 | 容器打包了应用程序及其依赖环境，确保开发、测试和生产环境的一致性，减少了 “在我机器上运行正常，但是换个地方就不行了” 的问题，从而提高了开发和运维效率 | 尽管 VM 也提供隔离的环境，但每个 VM 中的 OS 和依赖项差异可能较大，不如容器那样一致和标准化。 |
> | 存储效率   | 容器使用了分层文件系统（如 AUFS、OverlayFS），多个容器可以共享底层的镜像层，只保存差异化的内容，节省了磁盘空间 | VM 的每个实例都有一个完整的磁盘镜像，因此存储开销更大，即使多个 VM 运行相同的 OS，也无法共享存储层。 |
>
> 总之，容器是 Docker 的核心，它提供了轻量级、隔离性强、可移植的运行环境，使得应用程序的部署更加高效和灵活。



## 2.3   仓库

在 Docker 中，**仓库（repository）**可以理解为存储和分发 Docker 镜像的地方。它类似于代码的版本控制系统（如 Git 仓库），但用于存放和管理 Docker 镜像。仓库是镜像的集中存储平台，使得开发者可以轻松地共享、分发和获取镜像。

主要概念如下：

1. 镜像库与镜像

    一个仓库中可以包含同一应用程序的多个版本的镜像。每个镜像都通过一个唯一的**标签（tag）**进行标识。例如，Nginx 这个仓库可能包含多个镜像版本，标签可能是 1.18、1.19 或 Latest。这样，用户可以拉取到某个特定版本的镜像。

2. 公共仓库 vs 私有仓库

    -   公共仓库：任何人都可以访问和下载镜像。Docker 的官方镜像仓库称为 Docker Hub，它是最广泛使用的公共仓库，包含了大量由官方和社区维护的镜像。
    -   私有仓库：用户可以设置私有仓库，存储自己不想公开的镜像。私有仓库适合企业内部使用，确保敏感应用程序镜像的安全性。

3. Docker Hub

    Docker Hub 是最常用的公共镜像仓库。它允许用户上传、下载和管理 Docker 镜像，并提供了大量的官方镜像和社区镜像。开发者可以在 Docker Hub 上搜索现有的镜像，或者将自己的镜像推送到 Docker Hub 以供他人使用。常见镜像如 Nginx、Mysql 等都托管在Docker Hub 上。

4. 仓库操作

    Docker 允许用户通过命令行工具与仓库进行交互，常见操作包括：

    -   拉取镜像（`pull`）：从仓库下载镜像到本地，例如：`docker pull nginx:latest`。
    -   推送镜像（`push`）：将本地构建的镜像上传到仓库，例如：`docker push myrepo/myapp:1.0`。
    -   搜索镜像：可以在 Docker Hub 或其他仓库中搜索现有镜像，找到适合自己需求的镜像。

5. 私有仓库的构建

    除了 Docker Hub，用户可以通过工具（如 Docker Registry）搭建自己的私有仓库，用于内部团队或企业共享镜像。私有仓库的设置允许对镜像的访问权限进行严格的控制，确保只有授权用户可以推送或拉取镜像。

仓库的用途和优势：

- 版本管理：通过仓库，开发者可以轻松管理应用程序的不同版本镜像，并为每个版本打上标签，确保可以随时访问某个历史版本的镜像。
- 分发和共享：仓库使得镜像可以轻松在团队、社区或全球范围内共享，方便不同开发环境或生产环境快速获取镜像。
- 自动化部署：借助仓库，CI / CD 流程可以自动化地将最新的镜像推送到仓库，部署系统从仓库中拉取镜像，简化了部署过程。

> 【举例说明】假设你开发了一个 Web 应用并打包成了 Docker 镜像。你可以将这个镜像上传到 Docker Hub 的仓库中，分配一个版本标签（如 myapp:1.0）。你的同事或生产环境服务器可以通过 `docker pull myapp:1.0` 从仓库下载这个镜像，并直接运行你的应用。这一过程避免了手动传输镜像文件，也确保了不同环境运行的应用一致性。

总结来说，Docker 的仓库是存储和分发镜像的中心，通过仓库，镜像的管理、共享和分发变得更加便捷和高效。



# 3   安装

可以在自己电脑上尝试安装并使用



# 4   持久化



## 4.1   数据卷挂载

Docker **数据卷（volume）**是一种特殊的存储机制，专门用于 Docker 容器的数据持久化和共享。数据卷如同一个虚拟目录，是容器目录与宿主机目录之间映射的桥梁。容器的默认文件系统是临时的，当容器停止或删除后，存储在容器内部的数据也会随之丢失。为了在容器生命周期之外持久化数据，Docker 提供了「数据卷」功能。

### 4.1.1   数据卷的主要特性

1. 持久化数据：数据卷独立于容器的生命周期，因此当容器被删除或重启时，数据卷中的内容不会丢失。这使得数据可以在容器重建或迁移时得到保留。
2. 共享和协作：多个容器可以挂载同一个数据卷，从而实现数据共享。例如，一个数据库容器可以将数据存储在数据卷中，其他应用容器可以访问这个卷来读取数据。
3. 性能优化：相比于直接把数据写入容器文件系统，数据卷的 I／O 操作更快、更高效，尤其在数据读写频繁的场景下。
4. 备份与迁移：数据卷可以备份到其他存储设备，并挂载到不同的容器中，这使得数据迁移和恢复变得更简单。

### 4.1.2   创建和使用数据卷

数据卷的使用方式多样化。以下是一些常用的方式：

- 匿名卷：在运行容器时，如果只指定容器内的路径，Docker 会创建一个匿名卷。

    ```dockerfile
    docker run -v /data myimage
    ```

    这里的 `/data` 是容器内的路径，Docker 会自动创建一个匿名卷。

- 命名卷：可以给数据卷指定一个名称，方便在多个容器中重复使用。

    ```dockerfile
    docker run -v myvolume:/data myimage
    ```

    这里的 `myvolume` 是卷的名称，容器中的 `/data` 路径会与该卷挂载绑定。

- 绑定挂载：可以将主机上的某个目录绑定到容器中的路径上。

    ```dockerfile
    docker run -v /host/path:/container/data myimage
    ```

    这种方式适合在容器内访问主机数据，但不具备卷的独立性和自动管理功能。

### 4.1.3   应用场景

- 数据库存储：将数据库的存储路径映射到数据卷，确保数据不会因容器的重启或删除而丢失。
- 日志和配置文件共享：多个服务可以共享配置文件或日志文件，实现协同工作。
- 数据备份和迁移：数据卷可以备份到本地或云端，并可以恢复到其他环境的容器中。

### 4.1.4   总结

Docker 数据卷是持久化和共享容器数据的重要工具，使得容器应用的数据能够在生命周期外保留，同时支持多个容器协同访问，广泛应用于数据敏感的场景如数据库存储、配置文件共享等。



## 4.2   本地目录挂载

Docker **本地目录挂载（bind mount**）是一种将主机上的目录或文件「直接」挂载到 Docker 容器中的方式，使得容器能够访问主机上的数据。这种方式特别适合**需要在容器内访问主机数据的场景**，例如开发环境中的代码同步、日志文件查看等。

### 4.2.1   本地目录挂载的特点

1. 直接访问主机数据：容器可以直接读取、写入主机目录中的文件，方便数据共享和开发调试。
2. 实时同步：当主机上的数据发生更改，挂载到容器中的数据会同步更新（反之亦然），非常适合代码调试和实时日志查看。
3. 无需容器生命周期绑定：本地目录挂载与容器的生命周期无关，容器删除后主机上的数据依然保留。

### 4.2.2   使用本地目录挂载

在运行 Docker 容器时，可以使用 `-v` 或 `--mount` 参数来指定本地目录挂载：

#### a. 使用 `-v` 参数

`-v` 参数的格式为 `[主机路径]:[容器路径]`

```dockerfile
docker run -v /path/on/host:/path/in/container myimage
```

例如，将主机 `/home/user/app` 目录挂载到容器的 `/app` 目录：

```dockerfile
docker run -v /home/user/app:/app myimage
```

这样容器可以访问主机上的 `/home/user/app` 目录中的内容，并且所有更改都会实时反映在两端。

#### b. 使用 `--mount` 参数

`--mount` 提供了更详细的选项，格式为 `type=bind,source=[主机路径],target=[容器路径]`

```dockerfile
docker run --mount type=bind,source=/path/on/host,target=/path/in/container myimage
```

例如：

```dockerfile
docker run --mount type=bind,source=/home/user/app,target=/app myimage
```

### 4.2.3   本地目录挂载的应用场景

1. 开发环境：将代码目录挂载到容器中，便于在主机上修改代码后立即在容器中生效，适合需要快速调试的开发环境。
2. 日志查看：将容器日志或配置文件的目录挂载到主机上，便于日志文件的存储和查看。
3. 数据共享：多个容器可以同时挂载主机的同一个目录，便于容器间的数据共享。

### 4.2.4   注意事项

- 权限控制：容器对挂载目录的访问权限受限于主机目录的权限，确保主机路径具有适当的读写权限。
- 依赖主机路径：如果挂载的主机路径不存在，Docker 不会自动创建，需要用户确保路径存在。
- 不可移植性：本地目录挂载依赖于特定的主机路径，不适合在不同主机之间迁移。

本地目录挂载为 Docker 容器提供了一种高效、实时的数据共享方式，特别适用于开发环境和数据共享需求较高的场景。不过，由于其依赖于主机的特定路径，适合短期使用或特定主机上的应用，而不太适合需要跨环境迁移的场景。



## 4.3   二者对比

两种持久化方式我该用哪一个？

本地目录挂载和数据卷是 Docker 中两种不同的存储方式，用于将数据持久化到主机上。它们的区别主要在于管理方式、性能和适用场景。

|              | 数据卷（volume）                                             | 本地目录挂载（bind mount）                                   |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 管理方式     | 是 Docker 自己管理的一种存储方式，由 Docker 自动创建和管理。数据卷一般存储在 `/var/lib/docker/volumes` 目录下（路径可能因系统不同而异）。不需要指定主机目录，Docker 会为每个卷分配一个唯一的目录。 | 将主机上的指定目录直接挂载到容器中。路径必须是主机上的真实目录，例如 `/path/on/host`。Docker 不会自动管理或创建这个路径，需要手动确保它存在。 |
| 性能         | 由于数据卷是 Docker 原生的存储方式，性能通常更高，特别是在 Linux 上。此外，Docker 可以对数据卷进行优化，比如提供缓存和读写性能的提升。 | 性能可能略低于数据卷，特别是在 Docker for Windows 和 Docker for Mac 环境中，因为文件系统差异和数据同步机制可能导致速度下降。 |
| 适用场景     | 【跨容器共享数据】多个容器可以方便地共享同一个数据卷，实现数据共享。<br>【持久化数据】数据卷常用于数据库容器、文件存储等需要长期持久化数据的场景。<br>【备份与迁移】Docker 提供了便捷的命令来备份、恢复和迁移数据卷的数据。 | 【开发环境】在开发环境中，常用于将代码目录挂载到容器中，实现实时同步，便于调试。<br>【主机特定目录需求】适合有特定目录需求的场景，比如挂载某个应用日志目录，使容器访问主机上的日志文件。<br>【不适合跨平台】由于挂载的主机目录路径是固定的，在不同的主机或操作系统上路径可能会有所不同，不适合需要高移植性的场景。 |
| 生命周期管理 | 数据卷的生命周期与容器无关，即使容器删除了，数据卷仍然保留，数据不会丢失，除非手动删除 | 本地挂载的数据也是独立于容器存在的。只要主机路径存在，数据不会丢失，适合需要与主机文件系统保持一致的场景 |

【示例】

- 数据卷：

    ```dockerfile
      docker run -d
          -v my-data-volume:/data
          --name my-container
          my-image
    ```

    Docker 会在主机的 `/var/lib/docker/volumes/my-data-volume/_data` 目录中创建并管理 `my-data-volume` 数据。

- 本地目录挂载：

    ```dockerfile
    docker run -d
    	-v /path/on/host:/data
    	--name my-container
    	my-image
    ```

    这里 `/path/on/host` 是主机上实际存在的路径，容器可以直接访问该目录。

【总结】

- 数据卷更适合生产环境中的数据持久化和性能优化，便于跨平台移植和备份。
- 本地目录挂载更适合开发环境和特定目录访问需求，但不适合需要跨平台的场景。



# 5   镜像的使用



## 5.1   Dockerfile 语法

Dockerfile 是 Docker 用来自动构建镜像的脚本文件，通过定义一系列指令来描述如何构建容器镜像。每条指令在构建时都会生成一个新的镜像层。

以下是常用的 Dockerfile 语法和说明：

### 5.1.1   基础指令

- `FROM`：指定基础镜像，这是 Dockerfile 的第一条指令。

    例如：`FROM ubuntu:20.04`。表示以 ubuntu:20.04 作为基础镜像，后续指令会基于该镜像进行构建。

- `RUN`：在镜像内运行命令，例如安装软件、更新系统等。每个 RUN 指令会创建一个新层。

    例如：`RUN apt-get update && apt-get install -y python3`这个指令会在镜像中安装 Python 3。

- `CMD`：定义容器启动时要运行的命令，只有最后一个 CMD 指令会生效。它与`ENTRYPOINT`配合使用，用于设置默认参数。

    例如：`CMD ["echo", "Hello, World!"]`

- `ENTRYPOINT`：设置容器启动时的入口点，通常与 CMD 配合，用于定义默认参数。

    例如：`ENTRYPOINT ["python3", "app.py"]`

- `COPY`：将文件或目录从主机复制到镜像中。语法为 `COPY <源路径> <目标路径>`。

    例如：`COPY . /app`。这会将当前目录的内容复制到镜像的`/app`目录中。

- `ADD`：类似于`COPY`，但支持从 URL 下载文件或自动解压 tar 文件。

    例如：`ADD archive.tar.gz /app`

### 5.1.2   设置环境

- `ENV`：设置环境变量，容器启动后可以直接使用这些变量。

    例如：`ENV APP_ENV=production`，这样可以在容器中通过`$APP_ENV`来访问该变量的值。

- `EXPOSE`：声明容器在运行时监听的端口，但不实际开启端口。通常用于文档说明。

    例如：`EXPOSE 80`表示容器监听 80 端口，但需要`docker run -p`显式映射到主机端口。

### 5.1.3   文件系统操作

- `WORKDIR`：设置工作目录，后续指令的路径将基于此目录。

    例如：`WORKDIR /app`。这样后续的`COPY`和`RUN`指令都会基于`/app`目录。

- `VOLUME`：创建一个挂载点，使数据能够在容器之间共享。语法为 `VOLUME <路径>`。

    例如：`VOLUME /data`

### 5.1.4   其他指令

- `USER`：设置执行指令的用户。默认用户为 root，可以指定非特权用户。
    例如：`USER appuser`

- `ARG`：定义构建时的变量，可以在构建时传入参数，但不会保存在镜像中。
    例如：`ARG VERSION=1.0`

- `ONBUILD`：定义在其他 Dockerfile 中继承该镜像时触发的指令。
    例如：`ONBUILD RUN echo "This will run on build of child image"`



### 5.1.4   Dockerfile 示例

以下是一个简单的示例 Dockerfile：

```dockerfile
# 指定基础镜像
FROM python:3.9

# 设置环境变量
ENV APP_HOME /app

# 创建并切换到工作目录
WORKDIR $APP_HOME

# 将当前目录的内容复制到容器中
COPY . .

# 安装依赖
RUN pip install -r requirements.txt

# 暴露端口
EXPOSE 8080

# 设置启动命令
CMD ["python", "app.py"]
```


### 5.1.5   总结

Dockerfile 通过多种指令帮助我们自动构建和配置 Docker 镜像，核心指令包括 `FROM`、`RUN`、`CMD`、`COPY`、`ENV` 等，用来设置镜像基础、复制文件、配置环境和定义启动方式等。编写高效的 Dockerfile 可以减少镜像层数、缩短构建时间并提高镜像性能。



## 5.2   自定义镜像

自定义 Docker 镜像的过程通常包括编写 Dockerfile、构建镜像、测试镜像。通过 Dockerfile，你可以定义基础镜像、安装的软件、复制的文件、环境变量等配置。以下是自定义 Docker 镜像的步骤：

### 5.2.1 编写 Dockerfile

Dockerfile 是用于定义镜像的文本文件，每条指令描述如何构建镜像的一个步骤。一个典型的 Dockerfile 包含以下指令：

- 选择基础镜像：指定一个基础镜像，例如官方的 ubuntu、alpine、python 镜像等。

```dockerfile
FROM ubuntu:20.04
```

- 安装所需软件：使用 RUN 指令运行命令安装软件。例如，如果你需要安装 Python，可以使用：

```dockerfile
RUN apt-get update && apt-get install -y python3
```

- 复制文件到镜像中：使用 COPY 指令将代码或配置文件复制到镜像中。

```dockerfile
COPY . /app
```

- 设置工作目录：使用 WORKDIR 设置工作目录，以便后续命令都在此目录下运行。

```dockerfile
WORKDIR /app
```

- 安装依赖：例如安装 Python 项目的依赖：

```dockerfile
RUN pip install -r requirements.txt
```

- 暴露端口：使用 EXPOSE 指令声明服务的端口号。

```dockerfile
EXPOSE 5000
```

- 设置默认命令：使用 CMD 或 ENTRYPOINT 指令定义容器启动时执行的命令。

```dockerfile
CMD ["python3", "app.py"]
```

示例 Dockerfile

假设要自定义一个 Flask 应用的 Docker 镜像，可以编写如下 Dockerfile：

```dockerfile
# 选择 Python 3.9 作为基础镜像
FROM python:3.9

# 设置工作目录
WORKDIR /app

# 复制当前目录下的文件到容器中
COPY . .

# 安装依赖
RUN pip install -r requirements.txt

# 暴露端口
EXPOSE 5000

# 设置容器启动命令
CMD ["python", "app.py"]
```

### 5.2.2   构建 Docker 镜像

在包含 Dockerfile 的目录中运行以下命令来构建镜像。-t 标志用于为镜像设置名称和标签。

docker build -t my-flask-app .

此命令会读取 Dockerfile 并逐步执行每个指令来构建镜像，镜像名称为 my-flask-app。

### 5.2.3 运行和测试自定义镜像

构建完成后，可以运行容器并测试镜像的功能：

docker run -p 5000:5000 my-flask-app

这里的 -p 参数将容器的 5000 端口映射到主机的 5000 端口，以便你可以通过 localhost:5000 访问应用。

### 5.2.4 发布自定义镜像

构建和测试成功后，可以将镜像发布到 Docker Hub 或其他镜像仓库中，便于在其他环境中使用。

- 登录 Docker Hub：

```dockerfile
docker login
```

- 打标签：

```dockerfile
docker tag my-flask-app username/my-flask-app:latest
```

- 推送镜像到 Docker Hub：

```dockerfile
docker push username/my-flask-app:latest
```

### 5.2.5 总结

通过 Dockerfile，你可以灵活定制自己的镜像，添加应用代码、安装依赖、配置环境变量和启动命令。构建完成后，可以在本地或远程运行和分享该镜像，实现应用的快速部署和迁移。

# 6   部署



在 Docker 上部署 Java 项目和前端项目的流程稍有不同，因为它们的运行环境和依赖有所差异。下面分别介绍如何在 Docker 上部署这两类项目。

## 6.1 部署 Java 应用

这里以 Spring Boot 项目为例。

1.  创建 Dockerfile

    在 Java 项目根目录下创建一个 Dockerfile 文件，用于定义构建镜像的步骤：

    ```dockerfile
    # 使用官方 OpenJDK 作为基础镜像
    FROM openjdk:11-jre-slim
    
    # 设置工作目录
    WORKDIR /app
    
    # 复制项目的 JAR 文件到容器
    COPY target/myapp.jar /app/myapp.jar
    
    # 暴露应用的端口
    EXPOSE 8080
    
    # 运行 Java 应用
    ENTRYPOINT ["java", "-jar", "/app/myapp.jar"]
    ```

    【说明】

    -   `FROM openjdk:11-jre-slim`：使用一个较轻量的 JRE 镜像。
    -   `COPY target/myapp.jar /app/myapp.jar`：将编译好的 JAR 文件复制到容器中 /app 目录。
    -   `EXPOSE 8080`：暴露应用的端口（根据应用实际端口调整）。
    -   `ENTRYPOINT`：设置容器启动时执行的命令，这里用于启动 Java 应用。

2.  在项目根目录下执行以下命令，构建 Docker 镜像：

    ```dockerfile
    docker build -t my-java-app .
    ```

    这里的 `my-java-app` 是镜像名称，`-t` 指定标签名称，`.` 表示当前目录。

3.  运行容器

    构建完成后，可以使用以下命令启动容器：

    ```dockerfile
    docker run -d -p 8080:8080 --name java-app my-java-app
    ```

    【说明】

    -   `-p 8080:8080` 将容器的 8080 端口映射到主机的 8080 端口。
    -   `--name java-app` 为容器指定一个名称。
    -   `my-java-app` 是镜像名称。

    

## 6.2   部署前端

前端项目（例如 React、Vue、Angular 等）通常是静态文件，最终生成的内容可以通过 Nginx 等 Web 服务器进行部署。

1.  构建前端项目

    在本地使用项目的构建命令，生成静态文件。以 Vue 项目为例，执行以下命令：

    ```bash
    npm install
    npm run build
    ```

    这会在项目目录中生成一个 dist 文件夹（或其他指定的输出目录），其中包含构建后的静态文件。

2.  创建 Dockerfile

    在前端项目的根目录创建一个 Dockerfile 文件：

    ```dockerfile
    # 使用官方的 Nginx 镜像作为基础镜像
    FROM nginx:alpine
    
    # 复制构建好的前端静态文件到 Nginx 的默认根目录
    COPY dist /usr/share/nginx/html
    
    # 暴露 Nginx 默认端口
    EXPOSE 80
    
    # 启动 Nginx
    CMD ["nginx", "-g", "daemon off;"]
    ```

    【说明】

    -   `FROM nginx:alpine`：使用轻量级的 Nginx 镜像。
    -   `COPY dist /usr/share/nginx/html`：将本地的构建文件复制到 Nginx 的 Web 目录。
    -   `EXPOSE 80`：暴露 Nginx 的默认端口。

3.  构建 Docker 镜像

    在项目根目录下执行以下命令，构建 Docker 镜像：

    ```dockerfile
    docker build -t my-frontend-app .
    ```

4.  运行容器

    构建完成后，使用以下命令启动容器：

    ```dockerfile
    docker run -d -p 80:80 --name frontend-app my-frontend-app
    ```

    【说明】

    -   `-p 80:80` 将容器的 80 端口映射到主机的 80 端口。
    -   `--name frontend-app` 为容器指定一个名称。
    -   `my-frontend-app` 是镜像名称。



## 6.3   Docker Compose

Docker Compose 是一个用于**定义和运行多容器 Docker 应用的工具**。通常在复杂项目中，不仅需要一个容器来运行应用，还需要多个容器协同工作，例如应用容器、数据库容器、缓存服务等。Docker Compose 通过一个「配置文件」**统一管理这些容器**，使得应用的多容器环境更加易于管理和部署。

### 6.3.1   Docker Compose 的核心功能

1. 定义多容器服务：使用 YAML 文件来配置应用所需的所有服务，可以指定每个服务的镜像、端口、环境变量等设置。
2. 简化操作：使用简单的命令 (`docker-compose up`、`docker-compose down`) 来启动和停止所有服务，无需逐个容器管理。
3. 环境隔离：每个项目可以有独立的配置，Compose 会将项目中的容器、网络等资源隔离开，确保项目间互不影响。
4. 跨环境一致性：Docker Compose 文件可以轻松移植到不同环境中（如开发、测试、生产），实现一致的应用部署。

### 6.3.2   Docker Compose 文件结构

Docker Compose 使用 docker-compose.yml 文件来定义应用的多容器架构。以下是一个典型的 Compose 文件结构示例：

```yaml
version: '3'
services:
  web:
    image: my-web-app:latest   # 定义服务的镜像
    ports:
      - "5000:5000"            # 端口映射
    environment:
      - APP_ENV=production     # 环境变量
    depends_on:
      - db                     # 指定服务依赖

  db:
    image: mysql:5.7           # 使用官方的 MySQL 镜像
    environment:
      MYSQL_ROOT_PASSWORD: example  # 数据库密码
    volumes:
      - db-data:/var/lib/mysql # 数据卷，用于持久化数据库数据

volumes:
  db-data:                      # 定义数据卷，用于数据库数据持久化
```

示例解释：

- services：定义各个服务（容器），如 web 和 db。
- web 服务：运行应用的容器，使用镜像 my-web-app:latest，并将容器的 5000 端口映射到主机的 5000 端口。depends_on 表示在启动 web 服务之前先启动 db 服务。
- db 服务：运行 MySQL 数据库，使用 mysql:5.7 镜像，设置数据库环境变量，并使用数据卷 db-data 持久化数据。

### 6.3.3   常用命令

- 启动所有服务

    ```dockerfile
    docker-compose up
    ```

    此命令会读取 docker-compose.yml 文件，启动所有定义的服务。加上 `-d` 选项会以后台模式运行。

- 停止并删除所有服务

    ```dockerfile
    docker-compose down
    ```

    停止并清理运行的容器、网络和卷等资源。

- 查看服务日志

    ```dockerfile
    docker-compose logs
    ```

- 重启服务

    ```dockerfile
    docker-compose restart
    ```

### 6.3.4   Docker Compose 的应用场景

- 开发环境：可以在本地轻松搭建多容器环境，模拟真实的生产环境，便于开发和调试。
- 测试环境：自动化测试场景下，使用 Docker Compose 配置应用所有依赖，可以快速创建和销毁测试环境。
- 轻松移植：同一个 docker-compose.yml 文件可以在多个环境中部署，实现开发、测试和生产环境的一致性。

### 6.3.5   总结

Docker Compose 是 Docker 的一个重要工具，用于定义和运行多容器应用。通过 docker-compose.yml 文件可以将应用所需的服务及其配置统一管理，使多容器应用的部署和维护更简单、高效。



# 7   ADS 实践

HIS MALL ADS 链接：https://his.huawei.com/portal/#/sec/intro?servicealias=ads&service_code=hrn:hic:servicemarket::service:ads

ADS 帮助文档链接：https://his.huawei.com/doc/#/page.html?service_code=hrn:hic:servicemarket::service:ads&group_id=84f42799d1754a75ad6f15b3467dc0c7&lang=zh_CN



# 附   常用指令手册

在初次学习 Docker 环境时，总是需要去查询各种指令且根据不同的需求更改指令。将常用的指令进行汇总和记录，便于提高学习和查询效率。

## A   1.1 镜像管理

- `docker pull <镜像名>`
    从 Docker 仓库（如 Docker Hub）下载镜像。
    例：`docker pull nginx:latest`

- `docker images`
    列出本地的所有 Docker 镜像。

- `docker build -t <镜像名> <Dockerfile 目录>`
    从指定目录中的 Dockerfile 构建镜像，并为镜像指定标签。
    例：`docker build -t myapp:1.0 .`

- `docker rmi <镜像 ID 或镜像名>`
    删除指定的 Docker 镜像。
    例：`docker rmi myapp:1.0`

- `docker tag <镜像 ID> <仓库名>:<标签>`
    给本地镜像打标签，使其可以推送到远程仓库。
    例：`docker tag myapp:1.0 myrepo/myapp:1.0`

- `docker push <仓库名>:<标签>`
    将镜像推送到指定的仓库。例：`docker push myrepo/myapp:1.0`

## A   1.2 容器管理

- `docker run <选项> <镜像>`
    启动一个基于指定镜像的容器。如果镜像不存在，会自动拉取。
    例：`docker run -d -p 80:80 nginx`（在后台启动一个nginx容器，并映射端口）

- `docker ps`
    列出当前正在运行的容器。

- `docker ps -a`
    列出所有容器（包括已停止的）。

- `docker stop <容器 ID 或容器名>`
    停止指定的容器。
    例：`docker stop mycontainer`

- `docker start <容器ID或容器名>`
    启动已停止的容器。
    例：`docker start mycontainer`

- `docker restart <容器ID或容器名>`
    重启指定的容器。

- `docker rm <容器ID或容器名>`
    删除指定的容器（容器必须已停止）。
    例：`docker rm mycontainer`

- `docker exec -it <容器 ID 或容器名> <命令>`
    在正在运行的容器内执行命令，常用于进入容器内部。
    例：`docker exec -it mycontainer /bin/bash`

- `docker logs <容器 ID 或容器名>`
    查看容器的日志输出。
    例：docker logs mycontainer

## A   1.3 容器和宿主机的网络与存储

- `docker port <容器 ID 或容器名>`
    查看容器的端口映射。
    例：`docker port mycontainer`

- `docker network ls`
    列出所有 Docker 网络。

- `docker network create <网络名>`
    创建一个新的 Docker 网络。
    例：`docker network create mynetwork`

- `docker network connect <网络名> <容器 ID 或容器名>`
    将一个容器连接到指定网络。

- `docker volume ls`
    列出所有 Docker 数据卷（volumes）。

- `docker volume create <卷名>`
    创建一个新的数据卷。
    例：`docker volume create mydata`

- `docker run -v <宿主目录>:<容器目录> <镜像>`
    运行容器并挂载宿主机目录到容器内。
    例：`docker run -v /host/data:/container/data myapp`

## A   1.4 容器状态与监控

- `docker inspect <容器 ID 或容器名>`
    查看容器的详细信息（JSON 格式），包括配置、网络、挂载等。

- `docker stats <容器 ID 或容器名>`
    实时显示容器的资源使用情况（CPU、内存等）。

- `docker top <容器 ID 或容器名>`
    查看容器中运行的进程列表。

## A   1.5 清理系统

- `docker system prune`
    清理未使用的 Docker 资源，包括镜像、容器、网络等。

- `docker container prune`
    删除所有已停止的容器。

- `docker image prune`
    删除所有未使用的镜像。

## A   1.6 Docker Compose 相关

- `docker-compose up`
    启动由 docker-compose.yml 文件定义的服务。
    例：`docker-compose up -d`（后台启动）

- `docker-compose down`
    停止并删除所有由 docker-compose.yml 启动的容器。

- `docker-compose ps`
    列出 docker-compose 启动的服务状态。