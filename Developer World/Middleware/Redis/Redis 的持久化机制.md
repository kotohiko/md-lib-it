Redis 提供了两种主要的持久化方式：**RDB (Redis Database Backup)** 和 **AOF (Append-Only File)**。它们各有优缺点，适用于不同的使用场景。以下是详细的解答：



## 1   RDB (Redis Database Backup)

### 1.1   特点

- **快照机制**：Redis 在==指定的时间间隔内==、==指定的写入次数==保存数据库的「快照」到一个二进制文件（默认名称：`dump.rdb`）中。这种方式适合对数据不敏感的场景。

    >   “Redis 在指定的时间间隔内保存数据库的快照到一个二进制文件 (`dump.rdb`) 中”，这里的 “快照” 指什么？
    >
    >   在 Redis 中，“快照” 是指在某个特定时间点将内存中的全部数据保存为持久化的二进制文件 (即 `dump.rdb`) 的过程。这个快照文件包含了 Redis 数据库==当时所有的键值对和数据状态==，可以看作是一个数据库的==完整备份==。
    >
    >   -   **快照的含义**
    >
    >      Redis 的快照机制（RDB 持久化）就像一张“照片”，记录了当前内存中所有数据的快照。这个快照是 Redis 在==某一时刻==将数据库的所有数据==序列化==并写入到磁盘文件中的==副本==。如果 Redis 发生宕机或重启，用户可以通过读取这个快照文件将数据库恢复到==快照保存时的状态==。
    >
    >   -   **操作过程**
    >
    >      当 Redis 触发 RDB 快照时，它会将所有的键值对和相关数据结构（如字符串、列表、集合等）写入一个 `.rdb` 文件中。之后，这个文件可以用于数据库的恢复。快照保存时是==增量式的==，即每次快照都会基于上一次保存的状态更新。
    >
    >   -   **触发机制**
    >
    >      Redis 可以根据配置定期进行快照，也可以通过命令手动触发。例如，配置项 `save 60 10000` 意味着在 60 秒内有 10,000 次写操作时，会自动生成一个新的快照。
    >
    >   -   **快照的用途**：
    >
    >      - **备份**：生成快照文件后可以复制到其他地方作为备份，以便在 Redis 宕机或数据丢失时进行恢复。
    >      - **灾难恢复**：如果 Redis 因为某些原因停止运行，恢复时可以加载最近的快照文件将数据还原到生成快照的那个时间点。
    >
    >   -   **快照的局限**：
    >      由于快照是定期保存的，如果 Redis 在快照生成后但在下一个快照生成前发生了宕机，那么在这段时间内的写操作将会丢失。因此，快照机制不适合那些需要高度数据一致性和实时持久化的场景。
    >
    >   总的来说，Redis 中的快照是对数据库当前状态的一个完整备份，便于在系统重启或故障后进行数据恢复。

- **轻量级**：RDB 文件相对较小，Redis 只需在特定时刻执行快照，平时不会影响 Redis 的正常运行，性能影响较小。

- **恢复速度快**：RDB 文件是紧凑的二进制格式，加载速度快，恢复数据较为高效。

- **数据丢失风险较高**：由于是定时生成快照，Redis 在最近一次快照和宕机之间的数据将会丢失，==不适合对数据一致性要求高的场景。==

### 1.2   优缺点与适用场景

#### 1.2.1   优缺点

-   优点：
    -   **快速加载**。RDB 生成的快照文件是压缩的二进制文件，适合备份和灾难恢复。
    -   **低资源占用**。RDB 持久化在 Redis 主线程之外影响，不会对主线程产生太大影响。
-   缺点：
    -   **数据丢失风险**。由于 RDB 是间歇性保存的快照，如果 Redis 崩溃，可能会丢失上次保存快照后的数据。

#### 1.2.2   适用场景

- 更加注重性能而非数据一致性的场景。
- 可以容忍一定数据丢失的系统，例如缓存系统。
- 灾难恢复与备份。

### 1.3   配置

通过 `redis.conf` 文件或 Redis 的配置命令来配置 RDB 的保存策略：
```bash
save 900 1   # 在900秒内，如果有至少1次写操作，保存快照
save 300 10  # 在300秒内，如果有至少10次写操作，保存快照
save 60 10000 # 在60秒内，如果有至少10000次写操作，保存快照
```

如果希望禁用 RDB 持久化：
```bash
save ""  # 禁用 RDB 持久化
```

### 1.4   命令

#### 1.4.1   概述

-   `save`：在主线程生成 RDB 文件，因此生成期间，主进程无法执行正常的读写命令，需要等待 RDB 结束。
-   `bgsave`：采用 fork 操作得到子进程，在子进程执行 RDB 生成，不会阻塞主进程。默认使用 `bgsave`。

#### 1.4.2   `bgsave` 流程

1.  检查子进程（检查是否存在 AOF／RDB 的子进程正在进行），如有则返回错误。
2.  触发持久化。调用 `rdbsaveBackGround`。
3.  开始 fork，子进程执行 RDB 操作，同时主进程响应其他操作。
4.  RDB 完成后，替换原来的旧 RDB，子进程退出。

##### 注意事项

1.  fork 操作会产生==短暂的阻塞==，微妙级别操作过后，不会阻塞主进程，整个过程==并非完全的非阻塞==。
2.  RDB 由于是快照备份所有的备份，而不是像 AOF 那样存写命令，因为 Redis 实例重启后恢复数据的速度可以得到保证，大数据量下比 AOF 快很多。
3.  fork 操作利用了写时复制^注^，类似于 `CopyOnWriteArrayList`。

>   写时复制
>
>   在创建子进程时，不会直接将主进程地址空间全部复制，而是共享同一个内存。之后如果任意一个进程需要对内存进行修改操作，内存会重新复制一份提供给修改后的进程单独使用。



## 2   AOF (Append-Only File)

### 2.1   特点

- **日志机制**：AOF 通过将==每个写操作==追加记录到日志文件 (`appendonly.aof`) 中，可以==记录所有的写操作==并在==重启时进行重放，确保每一条命令都被执行==。
- **更高的数据安全性**：AOF 记录的是每个写命令，因此可以做到几乎实时地持久化。可配置不同的刷盘策略（如每次写、每秒一次或操作系统自行决定）。
- **文件较大**：由于 AOF 会记录所有写操作，文件会比 RDB 大许多，并且随着时间增长会越来越大。Redis 提供了 ==AOF 重写机制==来压缩文件。
- **恢复速度相对较慢**：相比于 RDB，AOF 在恢复时需要重新执行所有写命令，恢复时间较长。

### 2.2   优缺点与适用场景

#### 2.2.1   优缺点

-   优点
    -   AOF 机制比 RDB 机制更加可靠，因为 AOF 文件记录了 Redis 执行的所有写命令，可以在每次写操作命令执行完毕后都落盘存储。 
-   缺点
    -   AOF 机制生成的文件比 RDB 更大。
    -   AOF 机制对于数据恢复的时间比 RDB 机制更加耗时。

#### 2.2.2   适用场景

- 对数据一致性要求较高的场景。
- 不能容忍数据丢失的系统，例如金融、订单系统等。

### 2.3   配置

在 `redis.conf` 中可以启用 AOF：
```bash
appendonly yes   # 启用 AOF
appendfsync everysec  # 每秒同步到磁盘，这是折中的方案，性能和数据安全性平衡较好
```

还可以根据需求选择其他的 `appendfsync` 策略：
- `always`：每次有写操作就进行 `fsync`，==最安全但性能较差==。
- `everysec`：每秒同步一次，折中方案。最多会丢失 1 秒的数据。
- `no`：由操作系统决定何时同步，性能最佳但可能会丢失更多数据。

>   设置 `always` 一定保证数据不丢失吗？
>
>   不能，因为 Redis 是先执行命令再写入 AOF，倘若执行命令写入 AOF 这段时间 Redis 宕机了，重启后也无法利用 AOF 恢复。

### 2.4   AOF 重写配置

当 AOF 文件过大时，Redis 会自动进行重写以减少文件体积：
```bash
auto-aof-rewrite-percentage 100  # 当AOF文件比上次重写时增加了100%时，触发重写
auto-aof-rewrite-min-size 64mb   # 只有AOF文件大于64MB时才进行重写
```



## 3   如何选择

- 如果对数据安全性要求很高，建议使用 AOF，并选择 `everysec` 模式。
- 如果更注重性能且可以容忍一定的数据丢失，可以选择 RDB。
- 也可以同时启用 RDB 和 AOF，这是 Redis 4.0 推出的新机制。RDB 负责周期性的备份，AOF 负责实时日志记录，从而兼顾数据恢复速度和数据安全性。
