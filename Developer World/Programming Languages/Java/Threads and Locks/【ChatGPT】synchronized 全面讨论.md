## 1   如何使用 `synchronized`



## 2   详解 `synchronized`

Java 的 `synchronized` 是一种==内置的==^注^锁机制，用来解决多线程环境下的并发问题，确保==共享资源==在==同一时刻==只能被==一个线程==访问。`synchronized` 能够保证线程的「原子性」、「可见性」和「有序性」，这些都是 **Java 内存模型（Java Memory Model, JMM）**的核心概念。我们从以下几个方面详细讲述 `synchronized` 的原理。

>   【问问 AI】“内置” 的锁机制，这个 “内置” 指什么？
>
>   在 Java 中，**内置**（built-in）锁机制指的是语言本身提供的、无需额外库或复杂配置即可直接使用的同步机制。具体来说，这个 “内置” 有以下几个方面的含义：
>
>   1.  **语言层面支持**：`synchronized` 是 Java 语言的一个关键字，直接由 Java 编译器和虚拟机（JVM）支持。开发者可以在代码中直接使用它，而不需要依赖外部库或工具。
>   2.  **无须手动管理**：使用 `synchronized` 时，Java 会自动处理锁的获取和释放，避免了手动管理锁的复杂性和可能的错误（如死锁、忘记释放锁等）。
>   3.  **提供简单的线程安全**：通过 `synchronized`，开发者可以方便地对共享资源进行保护，确保多线程环境下的安全性和一致性。这种简洁性使得它成为 Java 中常用的线程同步机制。
>   4.  **不依赖于其他组件**：`synchronized` 不依赖于第三方库或框架，它是 Java 核心库的一部分，可以在任何 Java 应用程序中使用。
>
>   总的来说，**内置**指的是 Java 语言自带的、易于使用的锁机制，使得多线程编程更加简便和安全。

### 2.1   `synchronized` 的工作原理

`synchronized` 可以用于「方法」或「代码块」上，来对对象的**监视器（`Monitor`）**加锁。每个对象^注^都有一个**监视器锁（monitor lock）**。==当线程执行 `synchronized` 方法或代码块时，会尝试获得该对象的监视器锁。==如果成功获取，线程就能进入临界区^注^执行代码，执行完毕后会释放锁；如果另一个线程尝试获取同一个对象的锁，它将被阻塞，直到第一个线程释放锁为止。

>   【问问 AI】
>
>   ① 我想问下，对象的这个监视器锁是放在对象的哪个部位，对象头（Header）吗？
>
>   ChatGPT：是的，==Java 对象的监视器锁确实是放在**对象头（Object Header）**中。==
>
>   在 HotSpot 虚拟机中，每个 Java 对象在内存中可以分为三部分：
>
>   1.  **对象头（Object Header）**：存储了与对象锁相关的信息、哈希码（HashCode）、GC 信息、类元数据指针等。
>   2.  **实例数据（Instance Data）**：存放对象的实际字段值，包括父类继承下来的字段。
>   3.  **对齐填充（Padding）**：为了让对象的大小成为 8 字节的整数倍而添加的空白数据。
>
>   对象头中最关键的部分是 **Mark Word**，它是一个==存储对象锁信息的地方==，具体内容会随着对象的不同状态而改变（如锁的类型、哈希码等）。==**Mark Word** 是实现对象锁和线程同步的基础。==
>
>   ② 临界区是什么？不太明白
>
>   ChatGPT：**临界区（Critical Section）** 是指在多线程或并发编程中，一个或多个线程在某一段代码中访问共享资源（例如内存、文件、数据库等）时，==必须确保同时只有一个线程可以执行这一段代码。==临界区的存在是为了防止**竞态条件（Race Condition）**，即多个线程同时访问或修改共享资源而导致数据不一致或程序异常的情况。

#### 2.1.1   方法级别的 `synchronized`

当一个方法被声明为 `synchronized` 时，JVM 会自动在进入和退出该方法时获取和释放锁。==对于实例方法，它锁定的是当前实例对象（`this`），而对于静态方法，它锁定的是对应的 `Class` 对象。==

#### 2.1.2   代码块级别的 `synchronized`

代码块级别的 `synchronized` 更灵活，可以对任何对象加锁。使用方式是

```java
synchronized (锁对象) { 
    // 临界区代码
}
```

线程进入代码块时获取锁对象的监视器锁，退出代码块时释放锁。

### 2.2   `Monitor`（监视器锁）机制

`Monitor` 是 Java 中 `synchronized` 背后的==基础机制==。==每个对象都有一个 `Monitor`，当线程进入 `synchronized` 块或方法时，它必须先获得这个 `Monitor`。==在 JVM 中，`Monitor` 是和对象一起实现的，==通过「对象头」的 Mark Word 来管理对象的锁状态==。对象的锁状态包括以下几种状态（锁膨胀过程）：

-   **无锁（Unlocked）**：这是对象的初始状态，没有任何线程持有它的锁。
-   **偏向锁（Biased Locking）**：==如果某个线程第一次获取该对象的锁，并且没有其他线程竞争，它可以偏向该线程。==偏向锁是一个==轻量化（跟「轻量级」还不一样）==的锁，==当同一线程多次进入同步块时，可以减少锁的开销。==
-   **轻量级锁（Lightweight Locking）**: 如果偏向锁被撤销，==并且有其他线程尝试获取锁，但尚未形成竞争==，JVM 会将其升级为轻量级锁，利用 ==CAS== 操作在锁竞争时减少线程阻塞。
-   **重量级锁（Heavyweight Locking）**: 当线程竞争进一步加剧时，轻量级锁会膨胀为重量级锁，此时线程会被挂起并进入等待队列，直到获得锁。

通过 `Monitor`，Java 的 `synchronized` 实现了线程之间的互斥访问，保证线程安全。

### 2.3   内存语义与可见性

`synchronized` 除了确保线程的互斥执行外，还提供了「内存可见性保证」。它基于 Java 内存模型中的**内存屏障（Memory Barrier）**机制来实现：

-   **进入 `synchronized` 块时（加锁时）**: 会有一个**读屏障（Load Barrier）**，==强制线程从主内存中刷新「最新的共享变量」。==
-   **退出 `synchronized` 块时（释放锁时）**: 会有一个**写屏障（Store Barrier）**，==强制线程把对「共享变量」的修改写回主内存。==

这意味着，==一个线程在持有锁并修改共享变量时，其他线程无法看到这些修改。而当该线程释放锁时，所有对共享变量的修改都会被同步到主内存，其他线程在获取该锁时能够看到最新的变量值。==因此，`synchronized` 具备**内存可见性**，==确保了线程间的共享变量状态是最新的。==

### 2.4   与 JVM 指令集的关系

`synchronized` 的底层是通过 JVM 的「字节码指令」来实现的。在编译后的 `.class` 文件中，`synchronized` 方法或代码块分别对应以下指令：

-   **方法级别的 `synchronized`**：在方法中体现为 `ACC_SYNCHRONIZED` 标志，JVM 会自动在调用方法时对对象加锁，在退出方法时释放锁。
-   **代码块级别的 `synchronized`**：对应的是 `monitorenter` 和 `monitorexit` 指令。每当线程进入 `synchronized` 代码块时，JVM 会插入 `monitorenter` 指令获取锁，离开时插入 `monitorexit` 指令释放锁。

这些字节码指令是由 JVM 进行优化和调度的，它们最终会转化为操作系统层面的线程同步原语（如 `mutex` 或 `semaphore`），这是 `synchronized` 的底层实现。

### 2.5   锁优化：偏向锁、轻量级锁与自旋锁

为了减少 `synchronized` 带来的性能开销，JVM 引入了多种锁优化机制，如偏向锁、轻量级锁、自旋锁等：

-   **偏向锁（Biased Locking）**：在无竞争情况下，一个线程会 “偏向” 持有该锁，避免每次都需要加锁和解锁的操作。这可以显著减少没有竞争时的开销。
-   **轻量级锁（Lightweight Locking）**：在没有高竞争时，线程可以通过自旋等待（而不是阻塞）来尝试获取锁，避免线程上下文切换带来的性能开销。
-   **自旋锁**：线程在短时间内没有获取锁时，可以不阻塞线程，而是在 CPU 上自旋等待一段时间后再尝试获取锁，从而避免频繁的线程挂起和恢复。

这些锁优化可以提高 `synchronized` 的性能，使其在不同的竞争条件下表现出良好的适应性。

### 2.6   与 `ReentrantLock` 的比较

`synchronized` 是一种「隐式锁」机制，Java 5 后推出了 `ReentrantLock`，它是一种「显式锁」，具备更多==灵活性==（如公平锁、非公平锁的选择、可中断锁等待等）。==尽管 `ReentrantLock` 在某些场景下性能更优，但 `synchronized` 依然在大多数情况下被推荐使用，尤其是在代码可读性和简洁性要求较高的场景下，因为它简单且不易出错。==

### 2.7   面试官关注点总结

-   **锁的实现原理**: 详细解释锁的工作机制，包括锁膨胀过程（偏向锁、轻量级锁、重量级锁）和 JVM 字节码层面的实现。
-   **内存语义**: 强调 `synchronized` 提供了内存可见性保证，结合 Java 内存模型进行阐述。
-   **锁优化**: 解释偏向锁、自旋锁等 JVM 优化机制，以展示对 `synchronized` 在高性能场景中的应用理解。
-   **与其他锁的比较**: 比较 `synchronized` 和 `ReentrantLock` 的异同，说明在不同场景下如何选择使用哪种锁。

这样，面试官不仅会看到你对 `synchronized` 基础知识的掌握，还能看出你对其底层机制、性能优化的理解，以及你对实际开发中如何选择同步机制的深度思考。



## 3   `synchronized` 的实际应用

