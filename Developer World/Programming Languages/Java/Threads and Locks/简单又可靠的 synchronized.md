Java 中的 `synchronized` 关键字是一个非常重要的特性，它用于控制多个线程对共享资源的访问，以避免并发问题，如数据不一致和线程冲突。`synchronized` 可以应用于方法或代码块上，以确保在同一时刻只有一个线程可以执行该段代码或方法。下面详细解释 `synchronized` 的原理：



## 1   锁对象

在 Java 中，==每个对象都可以作为锁==。当一个线程访问某个对象的 `synchronized` 方法或代码块时，它首先尝试获取该对象的锁。如果锁已被其他线程持有，那么该线程将被阻塞，直到锁被释放。

- 对于 `synchronized` 方法，锁是当前实例对象（对于静态方法，锁是类的 Class 对象）。
- 对于 `synchronized` 代码块，锁是括号中指定的对象。



## 2   锁的获取与释放

- **获取锁**：当线程进入 `synchronized` 方法或代码块时，JVM 会尝试获取对应的锁。==如果锁已被其他线程持有，则当前线程会被阻塞，直到锁被释放。==
- **释放锁**：当线程退出 `synchronized` 方法或代码块时（无论是正常退出还是异常退出），JVM 会自动释放锁。



## 3   锁的粒度

锁的粒度指的是锁定的资源范围。锁的粒度越细，系统的并发性就越高，但管理锁的开销也越大。因此，==在设计多线程程序时，需要权衡锁的粒度。==



## 4   锁的升级与降级

Java 的 `synchronized` 关键字并不直接支持锁的升级（如从偏向锁升级到轻量级锁再到重量级锁）或降级，这是 Java SE 6 中引入的偏向锁、轻量级锁和重量级锁的概念，它们主要用于优化 `synchronized` 的性能。==这些锁的状态转换是由 JVM 自动完成的，以提高并发性能并减少锁的开销。==

- **偏向锁**：如果锁总是被同一个线程获取，那么 JVM 会优化这个锁，使其偏向于这个线程，以减少锁的开销。
- **轻量级锁**：如果锁被多个线程竞争，但竞争不是很激烈，JVM会使用轻量级锁，通过 CAS 操作来尝试获取锁，以减少线程阻塞的开销。
- **重量级锁**：如果锁的竞争非常激烈，JVM 会升级为重量级锁，这时会涉及到操作系统的**互斥锁（mutex）**，开销较大。



## 注意事项

- 过度使用 `synchronized` 可能会导致性能问题，因为它会限制并发性。
- 在设计多线程程序时，应尽量避免在 `synchronized` 块中进行耗时的操作，以减少锁的持有时间。
- 锁的粒度要适当，既要保证数据的一致性，又要尽量提高系统的并发性。

总之，`synchronized` 是 Java 中用于控制多线程访问共享资源的一种机制，它通过锁对象来实现对共享资源的互斥访问。了解 `synchronized` 的原理和注意事项，对于编写高效、安全的多线程程序至关重要。