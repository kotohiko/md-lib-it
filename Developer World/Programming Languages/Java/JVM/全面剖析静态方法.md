## 1   概述

Java 中的**静态方法（static method）**是与类相关联的方法，而不是与类的实例相关联。这意味着==你不需要创建类的对象就可以直接通过类名来调用这些方法==。下面是关于 Java 静态方法的一些关键点：

### 1.1   定义

静态方法使用 `static` 关键字定义。语法示例（`java.lang.Math#max(int, int)`）：

```java
    public static int max(int a, int b) {
        return (a >= b) ? a : b;
    }
```

### 1.2   特性

- **类级别访问**：静态方法属于类本身，而不是类的任何特定实例。因此，它们可以通过类名直接调用，例如 `ClassName.staticMethodName()`。
- **无隐式 `this` 引用**：静态方法中没有 `this` 关键字，因为 `this` 指向的是对象实例，而静态方法不依赖于任何实例。
- **内存位置**：静态方法存储在**方法区（Method Area）**，这是JVM内存模型的一部分，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- **生命周期**：==静态方法的生命周期与类相同，从类被加载到 JVM 时开始，直到程序结束或类卸载。==
- **静态上下文限制**：静态方法只能访问其他静态成员（包括变量和方法）。这是因为非静态成员需要一个具体的对象实例才能访问，而静态方法没有这样的实例。

### 1.3   使用场景

- **工具方法**：提供一些通用的功能，比如数学运算、字符串处理等，这些功能不需要依赖于特定的对象状态。
- **工厂方法**：用于创建对象的实例，尤其是当构造过程比较复杂时。
- **单例模式**：确保一个类只有一个实例，并提供一个全局访问点。



## 2   方法区（Method Area）

- 方法区是一个逻辑上的区域，它并不像堆和栈那样有明确的物理划分。在不同的 JVM 实现中，方法区可能有不同的实现方式。例如，在 HotSpot JVM 中，方法区的数据可以存储在永久代（Permanent Generation，简称 PermGen，在 JDK 8之前）或者元空间（Metaspace，在 JDK 8及之后）中。
- 方法区主要包含以下内容：
    - 类的结构信息（如运行时常量池、字段和方法数据、方法和构造函数的代码）
    - 静态变量
    - 即时编译后的代码



## 3   调用 `Math.max()` 方法的全过程

当你在 Java 中调用 `Math.max()` 方法时，整个过程涉及几个步骤，从方法的查找、类加载到实际执行。下面我将详细解释这个过程：

### 3.1   方法查找

- **编译时绑定**：`Math.max()` 是一个静态方法，并且是 `java.lang.Math` 类的一部分。由于它是一个静态方法，因此在编译时就已经确定了要调用的方法的具体实现。

### 3.2   类加载

- **检查是否已加载**：==JVM 会首先检查 `java.lang.Math` 类是否已经被加载。如果该类尚未被加载，则 JVM 会触发类加载机制。==
- **类加载器**：JVM 使用内置的**引导类加载器（Bootstrap Class Loader）**来加载位于 `rt.jar` 中的核心 Java 库，其中包括 `java.lang.Math` 类。这个类加载器负责加载标准的 Java API 类。
- **初始化阶段**：一旦 `java.lang.Math` 类被加载并链接完成，在首次访问静态方法或静态变量之前，JVM 还会执行任何存在的静态初始化代码块（如果有）。但`Math`类并没有这样的静态初始化块，因此这一步通常是即时完成的。

### 3.3   调用方法

- **参数传递**：当调用 `Math.max(a, b)`时，你需要提供两个参数 `a` 和 `b`，这两个参数必须是可以比较大小的数据类型，如 `int`、`long`、`float` 或 `double`。
- **方法执行**：`Math.max()` 方法内部逻辑非常简单，它只是比较两个参数，并返回较大的那个值。例如，对于 `int` 类型的参数，`Math.max(int a, int b)` 方法会比较 `a` 和 `b` 的值，并返回较大者。

### 3.4   返回结果

- **计算结果**：根据提供的参数，`Math.max()`会计算出最大值。
- **返回给调用者**：计算得到的最大值会被作为方法的结果返回给调用者。